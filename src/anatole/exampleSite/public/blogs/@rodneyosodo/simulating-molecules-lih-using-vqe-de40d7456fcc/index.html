<!doctype html><html dir=ltr lang=en data-theme class=html><head><title>Osodo Rodney
|
Simulating molecules(LiH) using VQE</title><meta charset=utf-8><meta name=generator content="Hugo 0.111.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=author content="Osodo Rodney"><meta name=description content="
      The path you have taken isn’t for the faint hearted


    "><meta name=google-site-verification content="rodneyosodo.com"><link rel=stylesheet href=/scss/main.min.b2e0cb07595e3519ab1193bb421914e06c0e26b0cc561fef23b3c6131d4d2ffa.css integrity="sha256-suDLB1leNRmrEZO7QhkU4GwOJrDMVh/vI7PGEx1NL/o=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/css/markupHighlight.min.31b0a1f317f55c529a460897848c97436bb138b19c399b37de70d463a8bf6ed5.css integrity="sha256-MbCh8xf1XFKaRgiXhIyXQ2uxOLGcOZs33nDUY6i/btU=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/fontawesome.min.b1c4e6a10bdbab01f33fff9d78816ee68cf9a9a731f07668afd546a79924cb80.css integrity="sha256-scTmoQvbqwHzP/+deIFu5oz5qacx8HZor9VGp5kky4A=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/solid.min.423dee17c62f55fa733a4ee13e00d523dfce88cc4f4ab4549a24ba36bd9de681.css integrity="sha256-Qj3uF8YvVfpzOk7hPgDVI9/OiMxPSrRUmiS6Nr2d5oE=" crossorigin=anonymous type=text/css><link rel=stylesheet href=/fontawesome/css/brands.min.b7d54133b27e5b4de15245b8e143de3e8ed2d674c706137274cedc9953f31917.css integrity="sha256-t9VBM7J+W03hUkW44UPePo7S1nTHBhNydM7cmVPzGRc=" crossorigin=anonymous type=text/css><link rel="shortcut icon" href=/favicons/favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicons/favicon-16x16.png><link rel=canonical href=https://rodneyosodo.com/blogs/@rodneyosodo/simulating-molecules-lih-using-vqe-de40d7456fcc/><script type=text/javascript src=/js/anatole-header.min.f9132794301a01ff16550ed66763482bd848f62243d278f5e550229a158bfd32.js integrity="sha256-+RMnlDAaAf8WVQ7WZ2NIK9hI9iJD0nj15VAimhWL/TI=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/anatole-theme-switcher.min.738c0e3a493854876aeab9e2316fd43f1936aeeac4cc6b3e60bb26456dba72ad.js integrity="sha256-c4wOOkk4VIdq6rniMW/UPxk2rurEzGs+YLsmRW26cq0=" crossorigin=anonymous></script><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://rodneyosodo.com/images/site-feature-image.png"><meta name=twitter:title content="Simulating molecules(LiH) using VQE"><meta name=twitter:description content="The path you have taken isn’t for the faint hearted"><meta property="og:title" content="Simulating molecules(LiH) using VQE"><meta property="og:description" content="The path you have taken isn’t for the faint hearted"><meta property="og:type" content="article"><meta property="og:url" content="https://rodneyosodo.com/blogs/@rodneyosodo/simulating-molecules-lih-using-vqe-de40d7456fcc/"><meta property="og:image" content="https://rodneyosodo.com/images/site-feature-image.png"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2020-08-23T12:37:52+00:00"><meta property="article:modified_time" content="2020-08-23T12:37:52+00:00"><meta property="og:site_name" content="Rodney Osodo"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"blogs","name":"Simulating molecules(LiH) using VQE","headline":"Simulating molecules(LiH) using VQE","alternativeHeadline":"","description":"
      The path you have taken isn’t for the faint hearted


    ","inLanguage":"en","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/rodneyosodo.com\/blogs\/@rodneyosodo\/simulating-molecules-lih-using-vqe-de40d7456fcc\/"},"author":{"@type":"Person","name":"Osodo Rodney"},"creator":{"@type":"Person","name":"Osodo Rodney"},"accountablePerson":{"@type":"Person","name":"Osodo Rodney"},"copyrightHolder":{"@type":"Person","name":"Osodo Rodney"},"copyrightYear":"2020","dateCreated":"2020-08-23T12:37:52.54Z","datePublished":"2020-08-23T12:37:52.54Z","dateModified":"2020-08-23T12:37:52.54Z","publisher":{"@type":"Organization","name":"Osodo Rodney","url":"https://rodneyosodo.com","logo":{"@type":"ImageObject","url":"https:\/\/rodneyosodo.com\/favicons\/favicon-32x32.png","width":"32","height":"32"}},"image":["https://rodneyosodo.com/images/site-feature-image.png"],"url":"https:\/\/rodneyosodo.com\/blogs\/@rodneyosodo\/simulating-molecules-lih-using-vqe-de40d7456fcc\/","wordCount":"1604","genre":[],"keywords":[]}</script></head><body class="body theme--light"><div class=wrapper><aside class=wrapper__sidebar><div class="sidebar
animated fadeInDown"><div class=sidebar__content><div class=sidebar__introduction><img class=sidebar__introduction-profileimage src=/images/profile.png alt="profile picture"><div class=sidebar__introduction-title><a href=/>Rodney Osodo</a></div><div class=sidebar__introduction-description><p>This is Rodney Osodo's website</p></div></div><ul class=sidebar__list><li class=sidebar__list-item><a href=https://www.linkedin.com/in/rodneyosodo rel=me aria-label=Linkedin title=Linkedin><i class="fab fa-linkedin fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://github.com/rodneyosodo rel=me aria-label=GitHub title=GitHub><i class="fab fa-github fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://gitlab.com/0x6f736f646f rel=me aria-label=Gitlab title=Gitlab><i class="fab fa-gitlab fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://twitter.com/b1ackd0t rel=me aria-label=Twitter title=Twitter><i class="fab fa-twitter fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.instagram.com/rodneyosodo/ rel=me aria-label=Instagram title=Instagram><i class="fab fa-instagram fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.tiktok.com/@b1ackd0t rel=me aria-label=TikTok title=TikTok><i class="fab fa-tiktok fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://www.youtube.com/@rodneyosodo rel=me aria-label=Youtube title=Youtube><i class="fab fa-youtube fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://stackoverflow.com/users/9017060/black-dot rel=me aria-label=StackOverflow title=StackOverflow><i class="fab fa-stack-overflow fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://rodneyosodo.medium.com/ rel=me aria-label=Medium title=Medium><i class="fab fa-medium fa-2x" aria-hidden=true></i></a></li><li class=sidebar__list-item><a href=https://open.spotify.com/show/2MBoVx1mlX0kjHVrooqasf rel=me aria-label=Spotify title=Spotify><i class="fab fa-spotify fa-2x" aria-hidden=true></i></a></li></ul></div><footer class="footer footer__sidebar"><ul class=footer__list><li class=footer__item>&copy;
2020-2023</li><li class=footer__item><a class=link href=/imprint/ title>imprint</a></li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script>
<script type=text/x-mathjax-config>
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></div></aside><main class=wrapper__main><header class=header><div class="animated fadeInDown"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span>
<span aria-hidden=true class=navbar-burger__line></span></a><nav class=nav><ul class=nav__list id=navMenu><li class=nav__list-item><a href=/ title>Home</a></li><li class=nav__list-item><a href=/blogs/ title>Blogs</a></li><li class=nav__list-item><a href=/portfolio/ title>Portfolio</a></li><li class=nav__list-item><a href=/publications/ title>Publications</a></li><li class=nav__list-item><a href=/talks/ title>Talks</a></li><li class=nav__list-item><div class=optionswitch><input class=optionswitch__picker type=checkbox id=menuoptionpicker hidden>
<label class=optionswitch__label class=optionswitch__label for=menuoptionpicker>Accomplishments <i class="fa fa-angle-down" aria-hidden=true></i></label><div class=optionswitch__triangle></div><ul class=optionswitch__list><li class=optionswitch__list-item><a href=/awards/ title>Awards</a></li><li class=optionswitch__list-item><a href=/certifications/ title>Certifications</a></li></ul></div></li><li class=nav__list-item><a href=/contact/ title>Contact</a></li></ul><ul class="nav__list nav__list--end"><li class=nav__list-item><div class=themeswitch><a title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></li></ul></nav></div></header><div class="post
animated fadeInDown"><div class=post__content><h1>Simulating Molecules(LiH) Using VQE</h1><blockquote><p>The path you have taken isn’t for the faint hearted</p></blockquote><p>Qiskit Summer School Final Project: Designing your implementation of a variational quantum eigensolver (VQE) algorithm that simulates the ground state energy of the Lithium Hydride (LiH) molecule.</p><p><img src=/images/blogimages/0__o78hE1xTtBDos6Q5.jpg alt></p><h3 id=introduction>INTRODUCTION</h3><p>Fundamentally, light was believed to be a wave. However, Albert Einstein found that light consisted of photons called quanta, which have energy determined by its frequency. Photons of visible light can be absorbed by an electron, thereby causing the electron to move from a low energy orbital to a high energy orbital.</p><p>Determining these properties is difficult for a classical computer since the electrons may be highly entangled. To model this accurately, we require more computational power, and this is where quantum computers come into play. Compared to classical computers, they are more efficient at handling entanglement.</p><p>LiH is a 12 body molecule containing 4 protons, 4 electrons, and 4 neutrons. This creates a 12 body model, which becomes intractable when simulating it both with a classical and quantum computer. So, this model reduces the First Quantized Molecular Hamiltonian to one two body interaction between two electrons in the hybridized p orbital and four one body interactions with their respective nuclei.</p><p><img src=/images/blogimages/0__NVIGs2CsKE3w3vWk.jpg alt></p><p>One of the essential properties is the ground state energy of a molecule. Finding the ground state energy of these molecules becomes harder as the size of the molecule increases, which is why until now, the largest simulated molecule is Beryllium Hydride. Molecular simulations’ problems grow exponentially as the size of molecules increase. Some of the applications of these problems are in drug discoveries.</p><blockquote><p><em>Richard Feynman said, “Nature isn’t classical, dammit, and if you want to make a simulation of nature, you’d better make it quantum mechanical, and by golly, it’s a wonderful problem because it doesn’t look so easy.”</em></p></blockquote><h3 id=process>PROCESS</h3><p>The variational principle explains how the energy of any trial wave function is greater than or equal to the system’s exact ground state energy.</p><p>It is important to find the minimum eigenvalue of a matrix; in Chemistry, the minimum eigenvalue of a Hermitian matrix is the ground state energy.</p><p><img src=/images/blogimages/1__BMsHquIAJpL3ZzdWLDuRCw.png alt></p><p><strong>1. We map the molecular Hamiltonians into qubit Hamiltonians.</strong> We find the fermionic operators and map the fermionic Hamiltonians to qubit Hamiltonians. For this transformation we use<br>1. Jordan Wigner transformation leads to N-local Hamiltonians<br>2. Bravyi-Kotoev transformation leads to log(N) local Hamiltonians<br>3. Partity transformation</p><p>We then copy the electron orbitals interactions to qubits.</p><h4 id=2-we-create-anansatz>2. We create an ansatz.</h4><p><img src=/images/blogimages/1__79c0qsVCWIxw0f__x9Cf0Xg.png alt></p><p>The expectation value of any wave function will be at least the minimum eigenvalue associated with the wave function.<br>The ground state of the Hamiltonian system is the smallest eigenvalue associated with the Hermitian matrix.</p><p><img src=/images/blogimages/1__6nb6kn6TiETzzMyTX__im__Q.png alt></p><p><strong>3. Parameter optimization</strong></p><p>One problem that arises is noise, meaning the energy calculations may not be true. We try and overcome this by gradient descent, which also has its problems. We use Simultaneous Perturbation Stochastic Approximation (SPSA) as the ideal optimizer. It works by perturbing all the parameters in random. Under noise, Sequential Least Squares Programming (SLSQP) and Constrained Optimization BY Linear Approximation (COBYLA) are preferred.</p><h3 id=implementation>IMPLEMENTATION</h3><p>Notebook is <a href=https://gist.github.com/rodneyosodo/698ee32dde649ace70ad1152d276f748>here</a></p><h3 id=defining-your-molecule>Defining your molecule:</h3><p>In this challenge, we will focus on LiH using the sto3g basis with the PySCF driver, which can be described in Qiskit as follows: ‘inter_dist’ is the interatomic distance.</p><p>inter_dist = 1.6</p><p>driver = PySCFDriver(atom=&lsquo;Li .0 .0 .0; H .0 .0&rsquo; + str(inter_dist), unit=UnitsType.ANGSTROM, charge=0, spin=0, basis=&lsquo;sto3g&rsquo;)</p><p>We also set up the molecular orbitals to be considered and can reduce the problem size when we map to the qubit Hamiltonian. Hence, the amount of time required for the simulations is reasonable for a laptop computer.</p><p># please be aware that the idx here with respective to original idx<br>freeze_list = [0]<br>remove_list = [-3, -2] # negative number denotes the reverse order</p><h3 id=now-you-can-start-choosing-the-components-that-make-up-your-vqe-algorithm>Now, you can start choosing the components that make up your VQE algorithm!</h3><h4 id=1-optimizers>1. Optimizers</h4><p>The most commonly used optimizers are <code>COBYLA,</code> <code>L_BFGS_B,</code> <code>SLSQP,</code> and <code>SPSA.</code></p><h4 id=2-qubitmapping>2. Qubit mapping</h4><p>There are several different mappings for your qubit Hamiltonian, <code>parity,</code> <code>bravyi_kitaev,</code> <code>jordan_wigner,</code> which in some cases can allow you to reduce the problem size further.</p><h4 id=3-initialstate>3. Initial state</h4><p>There are different initial states that you can choose to start your simulation. Typically people choose from the zero state <code>init_state = Zero(qubitOp.num_qubits)</code> and the UCCSD initial state <code>HartreeFock(qubitOp.num_qubits, num_spin_orbitals, num_particles, map_type, qubit_reduction)</code></p><h4 id=4-parameterized-circuit>4. Parameterized circuit</h4><p>There are different choices you can make in the form of variational forms of your parameterized circuit.</p><p><code>UCCSD_var_form = UCCSD(num_qubits, depth=depth, num_orbitals=num_spin_orbitals, num_particles=num_particles)</code></p><p><code>RY_var_form = RY(num_qubits, depth=depth)</code></p><p><code>RYRZ_var_form = RYRZ(num_qubits, depth=depth)</code></p><p><code>swaprz_var_form = SwapRZ(num_qubits, depth=depth)</code></p><h4 id=5-simulation-backend>5. Simulation backend</h4><p>There are different simulation backends that you can use to perform your simulation.</p><p><code>backend = BasicAer.get_backend('statevector_simulator')</code></p><p><code>backend = Aer.get_backend('qasm_simulator')</code></p><h3 id=compare-the-convergence-of-different-choices-for-building-your-vqe-algorithm>Compare the convergence of different choices for building your VQE algorithm</h3><p>Among the above choices, which combination do you think would outperform others and give you the lowest estimation of LiH ground state energy with the quickest convergence? Compare the results of different combinations against each other and the classically computed exact solution at a fixed interatomic distance, for example, <code>inter_dist=1.6</code>.</p><p>To access the intermediate data during the optimization, you would need to utilize the <code>callback</code> option in the VQE function:</p><p>counts = []<br>values = []<br>params = []<br>deviation = []<br>def store_intermediate_result(eval_count, parameters, mean, std):<br>counts.append(eval_count)<br>values.append(mean)<br>params.append(parameters)<br>deviation.append(std)</p><p><code>algo = VQE(qubitOp, var_form, optimizer, callback=store_intermediate_result)</code></p><p><code>algo_result = algo.run(quantum_instance)</code></p><h3 id=compute-the-ground-state-energy-of-lih-at-various-interatomic-distances>Compute the ground state energy of LiH at various interatomic distances</h3><p>By changing the parameter <code>inter_dist,</code> you can use your VQE algorithm to calculate the ground state energy of LiH at various interatomic distances, and potentially produce a plot as you see here. Note that the VQE results are very close to the exact results, and so the exact energy curve is hidden by the VQE curve.</p><h3 id=note-i-am-not-using-the-noisymodel>NOTE: I am not using the noisy model</h3><p>distances = np.arange(0.5, 4.0, 0.1)<br>exact_energies = []<br>vqe_energies = []<br>for dist in distances:<br>qubitOp, num_spin_orbitals, num_particles, qubit_reduction, shift = compute_LiH_qubitOp(map_type=&lsquo;parity&rsquo;, inter_dist=dist)<br># Classically solve for the exact solution and use that as your reference value<br>ref = exact_solver(qubitOp) + shift</p><pre><code># Specify your initial state  
init\_state = HartreeFock(num\_spin\_orbitals, num\_particles, &quot;parity&quot;, qubit\_reduction)

# Select a state preparation ansatz  
# Equivalently, choose a parameterization for our trial wave function.  
var\_form = UCCSD(num\_orbitals=num\_spin\_orbitals,  
                 num\_particles=num\_particles,  
                 initial\_state=init\_state,  
                 qubit\_mapping=&quot;parity&quot;)

# Choose where to run/simulate our circuit  
quantum\_instance = Aer.get\_backend('statevector\_simulator')

# Choose the classical optimizer  
optimizer = SPSA()

# Run your VQE instance  
vqe = VQE(qubitOp, var\_form, optimizer, callback=store\_intermediate\_result)

# Now compare the results of different compositions of your VQE algorithm!  
  
ret = vqe.run(quantum\_instance)  
vqe\_result = np.real(ret\['eigenvalue'\]) + shift  
print(&quot;Interatomic Distance:&quot;, np.round(1.4, 2), &quot;VQE Result:&quot;, vqe\_result, &quot;Exact Energy:&quot;, ref)  
exact\_energies.append(ref)  
vqe\_energies.append(vqe\_result)
</code></pre><p>plt.plot(np.arange(0.5, 4.0, 0.1), exact_energies, label=&ldquo;exact&rdquo;)<br>plt.plot(np.arange(0.5, 4.0, 0.1), vqe_energies, label=&ldquo;vqe&rdquo;)<br>plt.xlabel(&lsquo;Interatomic Distance (Angstrom)&rsquo;)<br>plt.ylabel(&lsquo;Bond Energy&rsquo;)<br>plt.legend()<br>plt.title(&lsquo;Bond energy vs interatomic distance&rsquo;)<br>plt.show()</p><p><img src=/images/blogimages/0__TvS14iQXT3tItaGJ.jpg alt></p><p># Dictionary of optimizers:<br>opt_dict = {&lsquo;SPSA&rsquo; , &lsquo;SLSQP&rsquo; , &lsquo;COBYLA&rsquo; , &lsquo;L_BFGS_B&rsquo;}</p><p>for opt in opt_dict:<br>print(&lsquo;Testing&rsquo;, str(opt) , &lsquo;optimizer&rsquo;)<br>qubitOp, num_spin_orbitals, num_particles, qubit_reduction, shift = compute_LiH_qubitOp(map_type , 1.5)<br># Classically solve for the exact solution and use that as your reference value<br>ref = exact_solver(qubitOp) + shift</p><pre><code># Specify your initial state  
init\_state = HartreeFock(num\_spin\_orbitals,num\_particles, qubit\_mapping='parity') 

# Select a state preparation ansatz  
# Equivalently, choose a parameterization for our trial wave function.  
var\_form = UCCSD(num\_orbitals=num\_spin\_orbitals, num\_particles=num\_particles, qubit\_mapping='parity')

# Choose where to run/simulate our circuit  
quantum\_instance = Aer.get\_backend('statevector\_simulator')

# Choose the classical optimizer  
if opt == 'SPSA':  
    optimizer = SPSA(max\_trials = 500)  
elif opt == 'SLSQP':  
    optimizer = SLSQP(maxiter = 1000)  
elif opt == 'L\_BFGS\_B':  
    optimizer = L\_BFGS\_B(maxfun = 1000 ,  maxiter = 1000)  
elif opt == 'COBYLA':  
    optimizer = COBYLA(maxiter = 1000)  
  
counts =\[\]  
values =\[\]  
params =\[\]  
deviation =\[\]

# Run your VQE instance  
vqe = VQE(qubitOp, var\_form, optimizer , callback = store\_intermediate\_result)  
vqe\_results = vqe.run(quantum\_instance)  
  
#Printing error in final value:  
ground\_state\_energy = vqe\_results\['eigenvalue'\] + shift  
energy\_error\_ground = np.abs(np.real(ref) - ground\_state\_energy)  
print('Error:', str(energy\_error\_ground))  
# Calculating energy error  
vqe\_energies = np.real(values) + shift  
energy\_error = np.abs(np.real(ref) - vqe\_energies)  
plt.plot(counts , energy\_error , label=str(opt))  
</code></pre><p>plt.legend()<br>plt.xlabel(&lsquo;Counts&rsquo;)<br>plt.ylabel(&lsquo;Energy Error/ Hartree&rsquo;)<br>plt.title(&lsquo;Energy Convergence of VQE: UCCSD Ansatz&rsquo;)</p><p><img src=/images/blogimages/0__b0tkqE70uTo7Irp9.jpg alt></p><p># Trying all combinations to get the most efficiency<br>maps_types = [&lsquo;parity&rsquo;] # For &lsquo;bravyi_kitaev&rsquo;, &lsquo;jordan_wigner&rsquo; we need another noise model eg ibmq_16_melbourne or ibmq_qasm_simulator</p><p>init_states = [&ldquo;HartreeFock(num_spin_orbitals, num_particles, map_type, qubit_reduction)&rdquo;,<br>&ldquo;Zero(qubitOp.num_qubits)&rdquo;]</p><p>var_forms = [&ldquo;UCCSD(num_orbitals=num_spin_orbitals, num_particles=num_particles, active_occupied=[0], active_unoccupied=[0, 1], initial_state=init_state, qubit_mapping=map_type, two_qubit_reduction=qubit_reduction)&rdquo;,<br>&ldquo;RY(qubitOp.num_qubits, depth=depth)&rdquo;,<br>&ldquo;RYRZ(qubitOp.num_qubits, depth=depth)&rdquo;,<br>&ldquo;SwapRZ(qubitOp.num_qubits, depth=depth)&rdquo;]</p><p>backends = [<br>&ldquo;Aer.get_backend(&lsquo;qasm_simulator&rsquo;)&rdquo;]</p><p>optimizers = [&ldquo;COBYLA(maxiter=opt_max_eval)&rdquo;,<br>&ldquo;L_BFGS_B(maxiter=opt_max_eval)&rdquo;,<br>&ldquo;SLSQP(maxiter=opt_max_eval)&rdquo;,<br>&ldquo;SPSA()&rdquo;]<br>depth = 1<br>opt_max_eval = 200<br>for map_type in maps_types:<br>for i_state in init_states:<br>for v_form in var_forms:<br>for be in backends:<br>for opt in optimizers:<br>print(&ldquo;map_type: &ldquo;, map_type)<br>print(&ldquo;i_state: &ldquo;, i_state)<br>print(&ldquo;v_form: &ldquo;, v_form)<br>print(&ldquo;be: &ldquo;, be)<br>print(&ldquo;opt: &ldquo;, opt)</p><pre><code>                qubitOp, num\_spin\_orbitals, num\_particles, qubit\_reduction = compute\_LiH\_qubitOp(map\_type, inter\_dist)  
                # Classically solve for the exact solution and use that as your reference value  
                ref = exact\_solver(qubitOp)

                # Specify your initial state  
                init\_state = eval(i\_state)

                # Select a state preparation ansatz  
                # Equivalently, choose a parameterization for our trial wave function.  
                var\_form = eval(v\_form)

                # Choose where to run/simulate our circuit  
                quantum\_instance = QuantumInstance(backend=eval(be),  
                                                    noise\_model=noise\_model,  
                                                    measurement\_error\_mitigation\_cls=CompleteMeasFitter,  
                                                    seed\_simulator=167, seed\_transpiler=167,)

                # Choose the classical optimizer  
                optimizer = eval(opt)

                # Run your VQE instance  
                counts = \[\]  
                values = \[\]  
                params = \[\]  
                deviation = \[\]  
                algo = VQE(qubitOp, var\_form, optimizer, callback=store\_intermediate\_result)  
                results = algo.run(quantum\_instance)  
                print('VQE Results: {:.12f}'.format(results.eigenvalue.real))  
                print('The total ground state energy is: {:.12f}'.format(results.eigenvalue.real))  
                print(&quot;Parameters: {}&quot;.format(results.optimal\_point))

                #plt.plot(counts, label=&quot;count&quot;)  
                plt.plot(values, label=&quot;Zero&quot;)  
                plt.xlabel('Eval count')  
                plt.ylabel('energy minimisation for various optimizers ')  
                plt.legend()  
                plt.show()

                #print(counts)  
                #print(values)  
                #print(params)  
                #print(deviation)  
                # Now compare the results of different compositions of your VQE algorithm!

                ## 8  
                print(&quot;---&quot;)
</code></pre><p>Hopefully, you have gained a firm understanding of how VQE works and can now implement one on your own. Leave some claps and follow me for more content. I worked with <a href=https://github.com/VictorCarlquist>Victor</a></p></div><div class=post__footer></div></div></main></div><footer class="footer footer__base"><ul class=footer__list><li class=footer__item>&copy;
2020-2023</li><li class=footer__item><a class=link href=/imprint/ title>imprint</a></li></ul></footer><script type=text/javascript src=/js/medium-zoom.min.1248fa75275e5ef0cbef27e8c1e27dc507c445ae3a2c7d2ed0be0809555dac64.js integrity="sha256-Ekj6dSdeXvDL7yfoweJ9xQfERa46LH0u0L4ICVVdrGQ=" crossorigin=anonymous></script><script defer type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity=sha384-e/4/LvThKH1gwzXhdbY2AsjR3rm7LHWyhIG5C0jiRfn8AN2eTN5ILeztWw0H9jmN crossorigin=anonymous></script>
<script type=text/x-mathjax-config>
      MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script></body></html>